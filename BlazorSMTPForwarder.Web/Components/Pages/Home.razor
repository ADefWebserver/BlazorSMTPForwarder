@page "/"
@using BlazorSMTPForwarder.Web.Services
@using Azure.Data.Tables
@using BlazorSMTPForwarder.Web.Components.Dialogs
@using System.Globalization
@using Microsoft.Extensions.Configuration
@using MimeKit
@using BlazorSMTPForwarder.ServiceDefaults.Models
@inject BlobEmailService EmailService
@inject Microsoft.JSInterop.IJSRuntime JSRuntime
@inject Radzen.DialogService DialogService
@inject TableServiceClient TableServiceClient
@inject IConfiguration Configuration

<PageTitle>Inbox</PageTitle>

<!-- Two-column mail layout -->
<RadzenRow Style="height:calc(100vh - 40px);">
    <!-- Left column: compose + recipient + messages -->
    <RadzenColumn Size="3" Style="height:100%; display:flex; flex-direction:column; gap:10px;">
        <RadzenButton Text="New message" Icon="play_arrow" ButtonStyle="ButtonStyle.Success" Style="width:100%;" Click="@NewMessageClick" />

        <!-- Recipient selector -->
        <div style="display:flex; flex-direction:column; flex:1 1 auto; min-height:0;">
            <RadzenLabel Text="Mailbox" Style="margin-bottom:4px; font-weight:bold;" />
            <RadzenDropDown Data="@_recipientFolders" @bind-Value="@_selectedRecipient"
                            Change="@OnRecipientChanged" Style="width:100%;"
                            Placeholder="Select mailbox..." />

            @if (_isLoadingMessages)
            {
                <div class="rz-p-3" style="text-align:center;">
                    <RadzenProgressBar Mode="ProgressBarMode.Indeterminate" />
                    <small>Loading messages...</small>
                </div>
            }
            else
            {
                @if (_messages == null || _messages.Count == 0)
                {
                    <div class="rz-p-3 rz-text-muted">No messages found.</div>
                }
                else
                {
                    <RadzenListBox Data="@_messages" @bind-Value="@_selectedMessageId"
                                   ValueProperty="Id" Change="@OnMessageSelected"
                                   Style="flex:1 1 auto; min-height:0; overflow:auto;">
                        <Template Context="m">
                            <div style="padding:4px 4px; display:flex; align-items:center; gap:6px; width:100%;">
                                <RadzenButton Icon="delete" ButtonStyle="ButtonStyle.Danger" Size="ButtonSize.Small" Click="@(async _ => await ConfirmDeleteAsync((EmailListItem)m))" />
                                <div style="min-width:0; flex:1 1 auto;">
                                    <div style="font-weight:600;" class="rz-truncate" title="@DisplaySubject(((EmailListItem)m).Subject)">@DisplaySubject(((EmailListItem)m).Subject)</div>
                                    <div class="rz-truncate" title="@((EmailListItem)m).From">@((EmailListItem)m).From</div>
                                </div>
                            </div>
                        </Template>
                    </RadzenListBox>
                }
            }
        </div>
    </RadzenColumn>

    <!-- Right column: preview -->
    <RadzenColumn Size="9" Style="height:100%; min-width:0; display:flex; flex-direction:column;">
        <!-- Actions row -->
        <div class="rz-d-flex rz-align-items-center" style="gap:12px; padding:4px 0;">
            @if (_currentEmail is not null)
            {
                <RadzenButton Text="Reply" Icon="reply" ButtonStyle="ButtonStyle.Primary" Size="ButtonSize.Small" Click="@(_ => ReplyToCurrent())" />
                <RadzenButton Text="Download .eml" Icon="download" ButtonStyle="ButtonStyle.Danger" Size="ButtonSize.Small" Click="@(_ => DownloadCurrent())" />
            }
        </div>
        <div style="flex:1 1 auto; min-height:0; overflow:auto; padding-right:4px;">
            @if (_isLoadingContent)
            {
                <div class="rz-p-3"><em>Loading content...</em></div>
            }
            else if (_currentEmail is null)
            {
                <div class="rz-text-muted" style="text-align:center; margin-top:3rem; font-size:1.2rem;">Select a message to view its details.</div>
            }
            else
            {
                <div class="rz-p-2" style="max-width:100%;">
                    <p><strong>Subject:</strong> @DisplaySubject(_currentEmail.Metadata.Subject)</p>
                    <p><strong>From:</strong> @_currentEmail.Metadata.From</p>
                    <p><strong>Received:</strong> @_currentEmail.Metadata.Received.ToLocalTime()</p>
                    <p><strong>Recipient User:</strong> @_currentEmail.Metadata.RecipientUser</p>
                    <hr />
                    @if (_isHtmlBody && !string.IsNullOrEmpty(_currentBody))
                    {
                        <iframe src="@GetDataUrl(_currentBody)" 
                                style="width:100%; height:500px; border:1px solid #ccc; background:#fff;" 
                                title="Email content">
                        </iframe>
                    }
                    else
                    {
                        <pre style="white-space:pre-wrap; font-size:0.82rem; line-height:1.15rem;">@_currentBody</pre>
                    }
                </div>
            }
        </div>
    </RadzenColumn>
</RadzenRow>

@code {
    private List<string>? _recipientFolders;
    private string? _selectedRecipient;
    private List<EmailListItem>? _messages;
    private EmailMessage? _currentEmail;
    private string? _selectedMessageId;
    private bool _isLoadingMessages;
    private bool _isLoadingContent;

    // SMTP settings from table
    private string? _settingsError;

    private string? _currentBody;
    private bool _isHtmlBody;

    private string DisplaySubject(string? subject) => string.IsNullOrWhiteSpace(subject) ? "(no subject)" : subject!;

    /// <summary>
    /// Converts HTML content to a data URL for use in iframe src attribute.
    /// This approach avoids issues with srcdoc encoding and sandbox restrictions.
    /// </summary>
    private static string GetDataUrl(string htmlContent)
    {
        if (string.IsNullOrEmpty(htmlContent))
            return "about:blank";
        
        var bytes = System.Text.Encoding.UTF8.GetBytes(htmlContent);
        var base64 = Convert.ToBase64String(bytes);
        return $"data:text/html;base64,{base64}";
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadSettingsAsync();
        await RefreshFoldersAsync();
    }

    private async Task LoadSettingsAsync()
    {
        try
        {
            var table = TableServiceClient.GetTableClient("SMTPSettings");
            await table.CreateIfNotExistsAsync();
            var response = await table.GetEntityIfExistsAsync<TableEntity>("SmtpServer", "Current");
            // Settings loaded successfully
        }
        catch (Exception ex)
        {
            _settingsError = ex.Message;
        }
    }

    private async Task RefreshFoldersAsync()
    {
        _recipientFolders = (await EmailService.GetRecipientFoldersAsync()).ToList();
        
        // Select first folder if none selected
        if (_recipientFolders.Any() && string.IsNullOrEmpty(_selectedRecipient))
        {
            _selectedRecipient = _recipientFolders.First();
        }

        if (!string.IsNullOrEmpty(_selectedRecipient))
        {
            await RefreshMessagesAsync();
        }
    }

    private async Task OnRecipientChanged()
    {
        _selectedMessageId = null;
        _currentEmail = null;
        await RefreshMessagesAsync();
    }

    private async Task RefreshMessagesAsync()
    {
        if (string.IsNullOrEmpty(_selectedRecipient)) return;
        _isLoadingMessages = true;
        StateHasChanged();
        try
        {
            _messages = (await EmailService.ListEmailsAsync(_selectedRecipient)).ToList();
        }
        finally
        {
            _isLoadingMessages = false;
            StateHasChanged();
        }
    }

    private async Task OnMessageSelected()
    {
        if (string.IsNullOrEmpty(_selectedMessageId)) return;
        _isLoadingContent = true;
        _currentEmail = null;
        _currentBody = null;
        StateHasChanged();

        try
        {
            var msg = await EmailService.GetEmailAsync(_selectedMessageId);
            if (msg != null)
            {
                _currentEmail = msg;
                
                // Parse body using MimeKit
                var (body, isHtml) = ExtractBodyWithMimeKit(msg.RawEml);
                _currentBody = body;
                _isHtmlBody = isHtml;
            }
        }
        finally
        {
            _isLoadingContent = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Extracts plain text body from raw EML using MimeKit.
    /// Prefers TextBody, falls back to converting HTML to plain text if needed.
    /// </summary>
    private static string ExtractPlainTextBodyWithMimeKit(string raw)
    {
        if (string.IsNullOrEmpty(raw)) 
            return string.Empty;

        try
        {
            // Skip custom X-SMTP-Server headers to get to the actual RFC822 message
            var normalizedRaw = raw.Replace("\r\n", "\n");
            var headerEnd = normalizedRaw.IndexOf("\n\n");
            string emlContent = raw;
            
            if (headerEnd > 0)
            {
                var afterFirst = headerEnd + 2;
                var firstLineAfter = normalizedRaw.Substring(afterFirst).Split('\n').FirstOrDefault() ?? "";
                
                if (firstLineAfter.Contains(':') && !firstLineAfter.StartsWith(" ") && !firstLineAfter.StartsWith("\t"))
                {
                    emlContent = raw.Substring(raw.IndexOf("\r\n\r\n") + 4);
                }
            }

            using var stream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(emlContent));
            var message = MimeMessage.Load(stream);
            return message.TextBody ?? message.HtmlBody ?? "";
        }
        catch
        {
            return FallbackExtractBody(raw);
        }
    }

    private static (string Body, bool IsHtml) ExtractBodyWithMimeKit(string raw)
    {
        if (string.IsNullOrEmpty(raw)) return (string.Empty, false);

        try
        {
            // Skip custom headers
            var normalizedRaw = raw.Replace("\r\n", "\n");
            var headerEnd = normalizedRaw.IndexOf("\n\n");
            string emlContent = raw;
            
            // Heuristic to detect if we have our custom headers block
            if (headerEnd > 0)
            {
                // Check if the next block looks like headers too (MIME headers)
                // If so, the first block was our custom metadata headers
                var afterFirst = headerEnd + 2;
                // Peek next line
                var firstLineAfter = normalizedRaw.Substring(afterFirst).Split('\n').FirstOrDefault() ?? "";
                
                // If it looks like a header (Key: Value) and not a continuation
                if (firstLineAfter.Contains(':') && !firstLineAfter.StartsWith(" ") && !firstLineAfter.StartsWith("\t"))
                {
                    // It's likely the real message starts after the first blank line
                    // But wait, our custom headers are prepended. 
                    // The BlobEmailService.GetEmailAsync reads the raw blob which includes custom headers.
                    // MimeMessage.Load can usually handle extra headers, but let's be safe.
                    // Actually, MimeKit is robust. Let's try loading the whole thing.
                }
            }

            using var stream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(raw));
            var message = MimeMessage.Load(stream);

            if (!string.IsNullOrEmpty(message.HtmlBody))
            {
                // Process HTML to embed images (CIDs)
                var html = message.HtmlBody;
                var cidMap = BuildCidMap(message);
                
                foreach (var cid in cidMap)
                {
                    html = html.Replace($"cid:{cid.Key}", cid.Value);
                }
                
                return (html, true);
            }
            
            return (message.TextBody ?? "", false);
        }
        catch
        {
            return (FallbackExtractBody(raw), false);
        }
    }

    private static string FallbackExtractBody(string raw)
    {
        if (string.IsNullOrEmpty(raw)) return string.Empty;
        var text = raw.Replace("\r\n", "\n");
        var first = text.IndexOf("\n\n");
        if (first < 0) return raw;
        var afterFirst = first + 2;
        var second = text.IndexOf("\n\n", afterFirst);
        if (second < 0)
            return text.Substring(afterFirst);
        return text.Substring(second + 2);
    }

    /// <summary>
    /// Builds a dictionary mapping Content-ID values to data URLs for embedded images.
    /// Also maps attachment filenames to data URLs for images referenced by filename.
    /// </summary>
    private static Dictionary<string, string> BuildCidMap(MimeMessage message)
    {
        var map = new Dictionary<string, string>();

        foreach (var attachment in message.BodyParts.OfType<MimePart>())
        {
            if (attachment.ContentId != null || (attachment.ContentType.MediaType == "image" && attachment.FileName != null))
            {
                using var ms = new MemoryStream();
                attachment.Content.DecodeTo(ms);
                var bytes = ms.ToArray();
                var base64 = Convert.ToBase64String(bytes);
                var dataUrl = $"data:{attachment.ContentType.MimeType};base64,{base64}";

                if (attachment.ContentId != null)
                {
                    map[attachment.ContentId.Trim('<', '>')] = dataUrl;
                }
                if (attachment.FileName != null)
                {
                    map[attachment.FileName] = dataUrl;
                }
            }
        }
        return map;
    }

    private async Task NewMessageClick()
    {
        await DialogService.OpenAsync<ComposeEmailDialog>("New Message",
               new Dictionary<string, object>() {
                   { "DefaultFrom", _selectedRecipient ?? "" }
               },
               new DialogOptions() { Width = "700px", Height = "620px", Resizable = true, Draggable = true });
        
        // Refresh after close (in case they sent to self)
        await RefreshFoldersAsync();
    }

    private static (string Address, string Display) ParseEmailAddressWithMimeKit(string rawEml, string headerName, string fallback)
    {
        try
        {
            using var stream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(rawEml));
            var message = MimeMessage.Load(stream);

            if (headerName == "From")
            {
                var from = message.From.Mailboxes.FirstOrDefault();
                if (from != null)
                {
                    var address = from.Address;
                    var display = string.IsNullOrWhiteSpace(from.Name) ? address : $"{from.Name} <{address}>";
                    return (address, display);
                }
            }
            else if (headerName == "To")
            {
                var to = message.To.Mailboxes.FirstOrDefault();
                if (to != null)
                {
                    var address = to.Address;
                    var display = string.IsNullOrWhiteSpace(to.Name) ? address : $"{to.Name} <{address}>";
                    return (address, display);
                }
            }

            return (fallback, fallback);
        }
        catch
        {
            return (fallback, fallback);
        }
    }

    private async void ReplyToCurrent()
    {
        if (_currentEmail is null) return;

        // Use MimeKit to parse email addresses properly
        var (fromAddress, fromDisplay) = ParseEmailAddressWithMimeKit(_currentEmail.RawEml, "From", _currentEmail.Metadata.From);
        var (toAddress, toDisplay) = ParseEmailAddressWithMimeKit(_currentEmail.RawEml, "To", _selectedRecipient ?? _currentEmail.Metadata.RecipientUser + "@example.com");
        
        var originalSubject = _currentEmail.Metadata.Subject;
        var subject = !string.IsNullOrWhiteSpace(originalSubject) && !originalSubject.StartsWith("re:", StringComparison.OrdinalIgnoreCase)
            ? "re: " + originalSubject
            : originalSubject;

        // Parse "Date" header to a friendly local string if possible
        // ... (omitted for brevity, similar to original)

        var body = $"\n\n\nOn {_currentEmail.Metadata.Received.ToLocalTime():g}, {fromDisplay} wrote:\n> " + 
                   (_currentBody ?? "").Replace("\n", "\n> ");

        await DialogService.OpenAsync<ComposeEmailDialog>("Reply",
               new Dictionary<string, object>() {
                   { "DefaultTo", fromAddress },
                   { "DefaultFrom", toAddress }, // Reply from the recipient of the original
                   { "DefaultSubject", subject },
                   { "DefaultBody", body }
               },
               new DialogOptions() { Width = "700px", Height = "620px", Resizable = true, Draggable = true });
        
        await RefreshFoldersAsync();
    }

    private void DownloadCurrent()
    {
        if (_currentEmail is null) return;
        var bytes = System.Text.Encoding.UTF8.GetBytes(_currentEmail.RawEml);
        var base64 = Convert.ToBase64String(bytes);
        var fileName = _currentEmail.Metadata.BlobName.Split('/').Last();
        var url = $"data:text/plain;base64,{base64}";
        JSRuntime.InvokeVoidAsync("eval", $"(function(){{var a=document.createElement('a');a.href='{url}';a.download='{fileName}';a.click();}})();");
    }

    private async Task ConfirmDeleteAsync(EmailListItem item)
    {
        var confirmed = await DialogService.Confirm($"Delete message '{DisplaySubject(item.Subject)}' from '{item.From}'?", "Confirm Delete", new ConfirmOptions() { OkButtonText = "Delete", CancelButtonText = "Cancel", CloseDialogOnOverlayClick = true });
        if (confirmed == true)
        {
            var ok = await EmailService.DeleteEmailAsync(item.BlobName);
            if (ok)
            {
                if (_currentEmail?.Metadata.Id == item.Id)
                {
                    _currentEmail = null;
                    _selectedMessageId = null;
                }
                await RefreshMessagesAsync();
            }
        }
    }
}
